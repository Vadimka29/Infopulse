
public class MyQueue<E> {
	private E[] m;
	private int start, end;
	
	@SuppressWarnings("unchecked")
	public MyQueue(){
		m = (E[]) new Object[2];
	}
	
	public void clear(){
		int tempSize = size();
		for(int i = 0; i < tempSize; i++){
			dequeue();
			start ++;
		}
	}
	public void info(){
		System.out.println("start: " + start);
		System.out.println("end: " + end);
	}
	public void enqueue(E s){
		if(size() >= m.length)
			resize();
		m[realIndex(end)] = s;
		end ++;
	}
	public E dequeue(){
		if(isEmpty())
			throw new RuntimeException("Queue is empty");
		E r = m[realIndex(start)];
		start ++;
		if(start >= m.length){
			start = realIndex(start);
		}
		return r;
	}
	public String toString(){
		StringBuffer buff = new StringBuffer();
		for(int i = start; i < end; i ++){
			buff.append(m[realIndex(i)]);
			buff.append(", ");
		}
		return buff.toString();
	}
	public int size(){
		if(end > start)
			return end - start;
		else
			return m.length - start + end;
	}
	public boolean isEmpty(){
		return size() == 0;
	}
	public E front(){
		if(isEmpty())
			throw new RuntimeException("Queue is empty");
		return m[realIndex(start)];
	}
	//служебные методы
	private int realIndex(int index){
		return (index % m.length);
	}
	private int realIndex(int index, int N){
		return (index % N);
	}
	private void resize(){
		@SuppressWarnings("unchecked")
		E[] n = (E[])new Object[m.length*2];
		for(int i = start; i < end; i++){
			n[realIndex(i,n.length)] = m[realIndex(i)];
		}
		m = n;
	}
}