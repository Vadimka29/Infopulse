
public class MyQueue<E> {
	private E[] m;
	private int start, end;
	
	@SuppressWarnings("unchecked")
	public MyQueue(){
		m = (E[]) new Object[3];
	}
	
	public void clear(){
		int tempSize = size();
		for(int i = 0; i < tempSize; i++){
			dequeue();
			start = (start +1) % m.length;
		}
	}
	public void info(){
		System.out.println("start: " + start);
		System.out.println("end: " + end);
	}
	public void enqueue(E s){
		if(isFull())
			resize();
		m[realIndex(end)] = s;
		end = (end +1) % m.length;
	}
	public E dequeue(){
		if(isEmpty())
			throw new RuntimeException("Queue is empty");
		E r = m[realIndex(start)];
		start = (start + 1) % m.length;
		return r;
	}
	public String toString(){
		StringBuffer buff = new StringBuffer("[");
		for(int i = start; i < end; i ++){
			buff.append(m[realIndex(i)]);
			buff.append(",");
		}
		buff.append("]");
		return buff.toString();
	}
	public int size(){
		if(end >= start)
			return end - start;
		else
			return m.length - start + end;
	}
	public boolean isEmpty(){
		return size() == 0;
	}
	public E front(){
		if(isEmpty())
			throw new RuntimeException("Queue is empty");
		return m[realIndex(start)];
	}
	//служебные методы
	private int realIndex(int index){
		return (index % m.length);
	}
	private int realIndex(int index, int N){
		return (index % N);
	}
	public boolean isFull(){
		int diff = end - start;
		if(diff == -1 || diff == m.length)
			return true;
		return false;
	}
	private void resize(){
		@SuppressWarnings("unchecked")
		E[] n = (E[])new Object[m.length*2];
		for(int i = start; i < start + size(); i++){
			n[realIndex(i,n.length)] = m[realIndex(i)];
		}
		m = n;
	}
}